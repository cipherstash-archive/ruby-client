require_relative "../../spec_helper"

require "cipherstash/index/bloom_filter"

describe CipherStash::Index::BloomFilter do
  # Generated by SecureRandom.hex(16)
  # The same key is used for each test run so that these tests are deterministic.
  let(:key) { "8b42157da439e06aa6f6d1ad8c1db72e" }

  describe ".new" do
    it "returns a bloom filter with empty bits" do
      filter = described_class.new(key)
      expect(filter.bits).to eq(Set.new())
    end

    it "provides a default for filter_size" do
      filter = described_class.new(key)
      expect(filter.filter_size).to eq(256)
    end

    it "allows filterSize opt" do
      filter = described_class.new(key, {"filterSize" => 512})
      expect(filter.filter_size).to eq(512)
    end

    it "provides a default for filter_term_bits" do
      filter = described_class.new(key)
      expect(filter.filter_term_bits).to eq(3)
    end

    it "allows filterTermBits opt" do
      filter = described_class.new(key, {"filterTermBits" => 16})
      expect(filter.filter_term_bits).to eq(16)
    end
  end

  describe "#add" do
    # In practice there will be 1 to filter_term_bits entries. Less than filter_term_bits entries will be in the set
    # in the case that any of the first filter_term_bits slices of the HMAC have the same value.
    it "adds filter_term_bits entries to bits" do
      filter = described_class.new(key)

      filter.add("yes")

      expect(filter.bits.length).to eq(filter.filter_term_bits)
    end

    it "returns the bloom filter instance" do
      filter = described_class.new(key)

      result = filter.add("yes")

      expect(result).to be(filter)
    end
  end

  describe "#subset?" do
    it "returns true when the other filter is a subset" do
      filter_a = described_class.new(key)
      filter_b = described_class.new(key)

      filter_a.add("yes")
      filter_b.add("yes")

      expect(filter_a).to be_subset(filter_b)
    end

    it "returns false when the other filter is not a subset" do
      filter_a = described_class.new(key)
      filter_b = described_class.new(key)

      filter_a.add("yes")
      filter_b.add("ner")

      expect(filter_a).not_to be_subset(filter_b)
    end

    it "returns true when the other filter is a subset and filters have multiple entries" do
      filter_a = described_class.new(key)
      filter_b = described_class.new(key)

      filter_a.add("c")
      filter_a.add("d")

      filter_b.add("a")
      filter_b.add("b")
      filter_b.add("c")
      filter_b.add("d")
      filter_b.add("e")

      expect(filter_a).to be_subset(filter_b)
    end
  end
end
